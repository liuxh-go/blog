# 常见排序算法

## 一、冒泡排序

### 思路

冒泡排序的思路很简单,就是两两挨个比较,把较小或较大的数交换到前面去,这样经历过几轮循环后,数组中小的数或者大的数就会“浮”到前面去,达到数组有序的效果

### 排序过程(以升序即从小到大顺序排列)
0. 初始化n为0
1. 第n个数和第n+1个数进行比较,如果第n+1个数小于第n个数,那么把第n个数和第n+1个数进行交换
2. 递增n(即n加1),重复`1`步骤直到遍历完整个数组
3. 根据数组长度重复`0`步骤(长度为l则重复l次)
4. 完成排序

### 示例代码
```go
func (this *Bubble) Sort() {
	data := this.data
	l := len(data)
	for i := 0; i < l; i++ {
		for j := 0; j < l-1; j++ {
			if data[j+1] < data[j] {
				data[j], data[j+1] = data[j+1], data[j]
			}
		}
	}
}
```
[完整代码](https://github.com/wshhz/algoAndData/blob/master/algo/sort/bubble.go)

### 性能分析

* 稳定排序
* 内排序
* 冒泡排序不需要使用额外的空间,所以空间复杂度为S(n)=O(1)
* 当数组本来就是有序的时候,此时为最好情况T(n)=O(n),最坏T(n)=O(n^2),平均情况T(n)=O(n^2)

## 二、选择排序

### 思路

选择排序其实和冒泡排序有点像,只是不是挨个比较交换;选择排序把待排序序列分为了有序序列和无序序列两个部分,循环的从无序序列从选出最小或最大的数放到有序序列中,当无序序列选择完毕时有序序列就是排序之后的序列

### 排序过程(以升序即从小到大顺序排列)

0. 初始化i=0
1. 划分有序序列R[0,i]和无序序列R[i+1,n],R为待排序序列
2. 从无序序列R[i+1,n]中选出最小的数,下标为min,将R[min]和R[i]进行交换
3. i增加1,继续步骤`2`直到i=n
4. 完成排序
   
### 示例代码
```go
func (this *Select) Sort() {
	data := this.data
	l := len(data)
	for i := 0; i < l-1; i++ {
		min := i
		for j := i; j < l; j++ {
			if data[j] < data[min] {
				min = j
			}
		}

		data[min], data[i] = data[i], data[min]
	}
}
```
[完整代码](https://github.com/wshhz/algoAndData/blob/master/algo/sort/select.go)

### 性能分析

* 稳定排序
* 内排序
* 选择排序使用常数级的额外空间,所以空间复杂度为S(n)=O(1)
* 最好情况T(n)=O(n^2),最坏T(n)=O(n^2),平均情况T(n)=O(n^2)

## 三、快速排序

### 思路

每次选择一个基准值,然后根据基准值将待排序序列分成比基准值小和比基准值大的两个序列,再递归的对这两个子序列进行快速排序,最终完成整个序列的排序

### 排序过程(以升序即从小到大顺序排列)

// TODO

### 示例代码

// TODO

### 性能分析

// TODO

## 四、插入排序

// TODO

## 五、希尔排序

// TODO

## 六、桶排序

// TODO

## 七、基数排序

// TODO

## 八、归并排序

// TODO

## 九、计数排序

// TODO

## 十、堆排序

// TODO